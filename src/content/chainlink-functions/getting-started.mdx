---
section: chainlinkFunctions
date: Last Modified
title: "Getting Started"
metadata:
  linkToWallet: true
whatsnext:
  {
    "Try out the Chainlink Functions Tutorials": "/chainlink-functions/tutorials",
    "Read the Architecture to understand how Chainlink Functions operates": "/chainlink-functions/resources/architecture",
  }
---

import { Aside, CopyText, CodeSample, ClickToZoom } from "@components"
import { Tabs } from "@components/Tabs"
import ChainlinkFunctions from "@features/chainlink-functions/common/ChainlinkFunctions.astro"

Learn how to make requests to the Chainlink Functions Decentralized Oracle Network (DON) and make any computation or API calls off-chain. Chainlink Functions is available on several blockchains (see the [supported networks page](/chainlink-functions/supported-networks)), but this guide uses Polygon Mumbai to simplify access to testnet funds. Complete the following tasks to get started with Chainlink Functions:

- Set up your web3 wallet and fund it with testnet tokens.
- Simulate a Chainlink Functions on the [Chainlink Functions
  Playground](https://functions.chain.link/playground).
- Send a Chainlink Functions request to the DON. The JavaScript source code makes an API call to the [Star Wars API](https://swapi.dev/) and fetches the name of a given character.
- Receive the response from Chainlink Functions and parse the result.

## Simulation

Before making a Chainlink Functions request from your smart contract, it is always a good practice to simulate the source code off-chain to make any adjustments or corrections.

1. Open the [Functions playground](https://functions.chain.link/playground).
1. Copy and paste the following source code into the playground's code block.

   <CodeSample lang="javascript" src="samples/ChainlinkFunctions/starwars-api.js" />

1. Under _Argument_, set the first argument to <CopyText text="1" code/>. You are going to fetch the name of the first Star Wars character.
1. Click on _Run code_. Under _Output_, you should see _Luke Skywalker_.

   <ClickToZoom src="/images/chainlink-functions/getting-started/simulation.jpg" />

## Configure your resources

### Configure your wallet

You will test on Polygon Mumbai, so you must have an Ethereum web3 wallet with enough MATIC and LINK tokens. MATIC is the native gas fee token on Polygon. You will use MATIC tokens to pay for gas whenever you make a transaction on Polygon Mumbai. On the other hand, you will use LINK tokens to pay the Chainlink Functions Decentralized Oracles Network (DON) for processing your request.

1. [Install the MetaMask wallet](/quickstarts/deploy-your-first-contract#install-and-fund-your-metamask-wallet) or other Ethereum web3 wallet.

1. Set the network for your wallet to the Polygon Mumbai testnet. If you need to add Mumbai to your wallet, you can find the chain ID and the LINK token contract address on the [LINK Token Contracts](/resources/link-token-contracts#mumbai-testnet) page.

   - <a
       class="erc-token-address"
       id="80001_0x326C977E6efc84E512bB9C30f76E30c160eD06FB"
       href="/resources/link-token-contracts#mumbai-testnet"
     >
       Polygon Mumbai testnet and LINK token contract
     </a>

1. Request testnet MATIC from the [Polygon Faucet](https://faucet.polygon.technology/).

1. Request testnet LINK from [faucets.chain.link/mumbai](https://faucets.chain.link/mumbai).

### Deploy a Functions consumer contract on _Polygon Mumbai_

1. Open the [GettingStartedFunctionsConsumer.sol](https://remix.ethereum.org/#url=https://docs.chain.link/samples/ChainlinkFunctions/GettingStartedFunctionsConsumer.sol) contract in Remix.

   <CodeSample src="samples/ChainlinkFunctions/GettingStartedFunctionsConsumer.sol" showButtonOnly={true} />

1. Compile the contract.
1. Open MetaMask and select the _Polygon Mumbai_ network.
1. In Remix under the **Deploy & Run Transactions** tab, select _Injected Provider - MetaMask_ in the **Environment** list. Remix will use the MetaMask wallet to communicate with _Polygon Mumbai_.

   <ClickToZoom src="/images/chainlink-functions/getting-started/injected-provider.jpg" />

1. Click the **Deploy** button to deploy the contract. MetaMask prompts you to confirm the transaction. Check the transaction details to make sure you are deploying the contract to _Polygon Mumbai_.

   <ClickToZoom src="/images/chainlink-functions/getting-started/deploy.jpg" />

1. After you confirm the transaction, the contract address appears in the **Deployed Contracts** list. Copy the contract address.

   <ClickToZoom src="/images/chainlink-functions/getting-started/deployed-contracts.jpg" />

### Create a subscription

Follow the [Managing Functions Subscriptions](/chainlink-functions/resources/subscriptions#create-a-subscription) guide to accept the Chainlink Functions Terms of Service (ToS), create a subscription, fund it, then add your consumer contract address to it.

You can find the Chainlink Functions Subscription Manager at [functions.chain.link](https://functions.chain.link/).

## Run the example

The example is hardcoded to communicate with Chainlink Functions on Polygon Mumbai. Read the [Examine the code](#examine-the-code) section for a detailed description of all components.

To run the example:

1.  In Remix under the **Deploy & Run Transactions** tab, expand your contract in the **Deployed Contracts** section.
1.  Expand the `sendRequest` function to display its parameters.
1.  Fill in the `subscriptionId` with your subscription ID and `args` with `[1]`, then click **transact** button.

    <ClickToZoom src="/images/chainlink-functions/getting-started/send-request.jpg" />

1.  Wait for the request to be fulfilled. You can monitor the status of your request on the Chainlink Functions Subscription Manager.
    <ClickToZoom src="/images/chainlink-functions/getting-started/request-fulfilled.jpg" />
1.  Once the status is _Success_, check the character name: In Remix, under the **Deploy & Run Transactions** tab, click on the `character` function, and you'll get the name of your character.

    <ClickToZoom src="/images/chainlink-functions/getting-started/character.jpg" />

Chainlink Functions is capable of much more than just computation. Try one of the [Tutorials](/chainlink-functions/tutorials) to see examples that can GET and POST to public APIs, securely handle API secrets, handle custom responses, and query multiple APIs.

## Examine the code

### Solidity code

<CodeSample src="samples/ChainlinkFunctions/GettingStartedFunctionsConsumer.sol" />

- To write a Chainlink Functions consumer contract, your contract must import [FunctionsClient.sol](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/functions/dev/1_0_0/FunctionsClient.sol) and [FunctionsRequest.sol](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/functions/dev/1_0_0/libraries/FunctionsRequest.sol). You can read the API references: [FunctionsClient](/chainlink-functions/api-reference/functions-client) and [FunctionsRequest](/chainlink-functions/api-reference/functions-request).

  These contracts are available in an NPM package so that you can import them from within your project.

  ```
  import {FunctionsClient} from "@chainlink/contracts/src/v0.8/functions/dev/v1_0_0/FunctionsClient.sol";
  import {FunctionsRequest} from "@chainlink/contracts/src/v0.8/functions/dev/v1_0_0/libraries/FunctionsRequest.sol";
  ```

- Use the FunctionsRequest.sol library to get all the functions needed for building a Chainlink Functions request.

  ```
  using FunctionsRequest for FunctionsRequest.Request;
  ```

- The latest request ID, latest received response, and latest received error (if any) are defined as state variables:

  ```
  bytes32 public s_lastRequestId;
  bytes public s_lastResponse;
  bytes public s_lastError;
  ```

- We define the `Response` event that your smart contract will emit during the callback

  ```
  event Response(bytes32 indexed requestId, string character, bytes response, bytes err);
  ```

- The Chainlink Functions router address and donID are hardcoded for Polygon Mumbai. Check the [supported networks page](/chainlink-functions/supported-networks) to try the code sample on another testnet.

- The `gasLimit` is hardcoded to `300000`, the amount of gas that Chainlink Functions will use to fulfill your request.

- The JavaScript source code is hardcoded in the `source` state variable. For more explanation, read the [JavaScript code section](#javascript-code).

- Pass the router address for your network when you deploy the contract:

  ```
  constructor() FunctionsClient(router)
  ```

- The two remaining functions are:

  - `sendRequest` for sending a request. It receives the subscription ID and list of arguments to pass to the source code. Then:

    - It uses the `FunctionsRequest` library to initialize the request and add the source code and arguments. You can read the API Reference for [Initializing a request](/chainlink-functions/api-reference/functions-request/#initializerequestforinlinejavascript) and [adding arguments](/chainlink-functions/api-reference/functions-request/#setargs).

      ```
      FunctionsRequest.Request memory req;
      req.initializeRequestForInlineJavaScript(source);
      if (args.length > 0) req.setArgs(args);
      ```

    - It sends the request to the router by calling the `FunctionsClient` `sendRequest` function. You can read the API reference for [sending a request](/chainlink-functions/api-reference/functions-client/#_sendrequest). Finally, it stores the request id in `s_lastRequestId` and returns it.

      ```
      s_lastRequestId = _sendRequest(
          req.encodeCBOR(),
          subscriptionId,
          gasLimit,
          jobId
      );
      return s_lastRequestId;
      ```

      **Note**: `_sendRequest` accepts requests encoded in `bytes`. Therefore, you must encode it using [encodeCBOR](/chainlink-functions/api-reference/functions-request/#encodecbor).

- `fulfillRequest` to be invoked during the callback. This function is defined in `FunctionsClient` as `virtual` (read `fulfillRequest` [API reference](/chainlink-functions/api-reference/functions-client/#fulfillrequest)). So, your smart contract must override the function to implement the callback. The implementation of the callback is straightforward: the contract stores the latest response and error in `s_lastResponse` and `s_lastError`, parses the `response` from `bytes` to `string` to fetch the character name before emitting the `Response` event.

  ```
  s_lastResponse = response;
  character = string(response);
  s_lastError = err;
  emit Response(requestId, s_lastResponse, s_lastError);
  ```

### JavaScript code

<CodeSample lang="javascript" src="samples/ChainlinkFunctions/starwars-api.js" />

This JavaScript source code uses [Functions.makeHttpRequest](/chainlink-functions/api-reference/javascript-source#http-requests) to make HTTP requests. The source code calls the `https://swapi.dev/` API to request a Star Wars character name. If you read the [Functions.makeHttpRequest](/chainlink-functions/api-reference/javascript-source#http-requests) documentation and the [Star Wars API documentation](https://swapi.dev/documentation#people), you notice that URL has the following format where `$characterId` is provided as parameter when making the HTTP request:

```
url: `https://swapi.dev/api/people/${characterId}/`
```

To check the expected API response for the first character, you can directly paste the following URL in your browser `https://swapi.dev/api/people/1/` or run the `curl` command in your terminal:

```bash
curl -X 'GET' \
  'https://swapi.dev/api/people/1/' \
  -H 'accept: application/json'
```

The response should be similar to the following example:

```json
{
  "name": "Luke Skywalker",
  "height": "172",
  "mass": "77",
  "hair_color": "blond",
  "skin_color": "fair",
  "eye_color": "blue",
  "birth_year": "19BBY",
  "gender": "male",
  "homeworld": "https://swapi.dev/api/planets/1/",
  "films": [
    "https://swapi.dev/api/films/1/",
    "https://swapi.dev/api/films/2/",
    "https://swapi.dev/api/films/3/",
    "https://swapi.dev/api/films/6/"
  ],
  "species": [],
  "vehicles": ["https://swapi.dev/api/vehicles/14/", "https://swapi.dev/api/vehicles/30/"],
  "starships": ["https://swapi.dev/api/starships/12/", "https://swapi.dev/api/starships/22/"],
  "created": "2014-12-09T13:50:51.644000Z",
  "edited": "2014-12-20T21:17:56.891000Z",
  "url": "https://swapi.dev/api/people/1/"
}
```

Now that you understand the structure of the API. Let's delve into the JavaScript code. The main steps are:

- Fetch `characterId` from `args`. Args is an array. The `characterId` is located in the first element.
- Make the HTTP call using `Functions.makeHttpRequest` and store the response in `apiResponse`.
- Throw an error if the call is not successful.
- The API response is located at `data`.
- Read the name from the API response `data.name` and return the result as a [buffer](https://nodejs.org/api/buffer.html#buffer) using the `Functions.encodeString` helper function. Because the `name` is a `string`, we use `encodeString`. For other data types, you can use different [data encoding functions](/chainlink-functions/api-reference/javascript-source#data-encoding-functions).
  **Note**: Read this [article](https://www.freecodecamp.org/news/do-you-want-a-better-understanding-of-buffer-in-node-js-check-this-out-2e29de2968e8/) if you are new to Javascript Buffers and want to understand why they are important.
